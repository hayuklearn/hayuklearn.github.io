import{_ as e,c as o,o as c,R as d}from"./chunks/framework.D6kTAKe3.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"HTTPS/HTTPS.md","filePath":"HTTPS/HTTPS.md"}'),l={name:"HTTPS/HTTPS.md"},a=d('<h2 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to &quot;前置知识&quot;">​</a></h2><h3 id="数字摘要与数字摘要算法" tabindex="-1"><code>数字摘要</code>与<code>数字摘要算法</code> <a class="header-anchor" href="#数字摘要与数字摘要算法" aria-label="Permalink to &quot;`数字摘要`与`数字摘要算法`&quot;">​</a></h3><h3 id="数字签名原理" tabindex="-1"><code>数字签名</code>原理 <a class="header-anchor" href="#数字签名原理" aria-label="Permalink to &quot;`数字签名`原理&quot;">​</a></h3><ul><li>发送端（服务端）</li></ul><ol><li><code>原始数据</code>经过<code>数字摘要算法</code>生成<code>数字摘要</code></li><li><code>私钥</code>对<code>数字摘要</code>进行加密生成<code>数字签名</code></li><li>将<code>原始数据</code>、<code>数字签名</code>打包发送</li></ol><ul><li>接收端（客户端）</li></ul><ol><li>提取<code>原始数据</code>，使用约定的<code>数字摘要算法</code>计算出<code>数字摘要</code>A</li><li>提取出<code>数字签名</code>，使用<code>公钥</code>对其解密得到<code>数字摘要</code>B</li><li>判断<code>数字摘要</code>A是否与<code>数字摘要</code>B一致</li></ol><h3 id="接收端如何获取到公钥-数字证书可以帮到你" tabindex="-1">接收端如何获取到<code>公钥</code>？<code>数字证书</code>可以帮到你 <a class="header-anchor" href="#接收端如何获取到公钥-数字证书可以帮到你" aria-label="Permalink to &quot;接收端如何获取到`公钥`？`数字证书`可以帮到你&quot;">​</a></h3><ul><li>发送端（服务端）</li></ul><ol><li>发送端向CA申请<code>数字证书</code></li><li><code>发送端公钥</code>经过<code>数字证书</code>里的<code>摘要算法</code>生成<code>数字摘要</code></li><li><code>数字证书私钥</code>对<code>数字摘要</code>进行加密生成<code>数字签名</code></li><li>将<code>发送端公钥</code>、<code>数字签名</code>、<code>数字证书</code>打包发送</li></ol><ul><li>接收端（客户端）</li></ul><ol><li>提取<code>发送端公钥</code></li><li>提取<code>数字证书</code>，校验<code>数字证书</code>是否可信</li><li>如果可信，使用<code>发送端公钥</code>和<code>数字证书</code>里的<code>摘要算法</code>计算出<code>数字摘要</code>A</li><li>从<code>数字证书</code>中拿到<code>数字证书公钥</code></li><li>提取出<code>数字签名</code>，使用<code>数字证书公钥</code>对其解密得到<code>数字摘要</code>B</li><li>判断<code>数字摘要</code>A是否与<code>数字摘要</code>B一致</li><li>如果一致，发送与接收双方可以利用非对称加密进行通信</li></ol><h2 id="http的不安全性" tabindex="-1">HTTP的不安全性 <a class="header-anchor" href="#http的不安全性" aria-label="Permalink to &quot;HTTP的不安全性&quot;">​</a></h2><ol><li>被中间人窃听（HTTPS可解决）</li><li>被中间人篡改（HTTPS可解决）</li><li>被中间人伪造（HTTPS可解决）</li><li>被中间人丢弃（HTTPS不可解决）</li></ol><h2 id="https概念" tabindex="-1">HTTPS概念 <a class="header-anchor" href="#https概念" aria-label="Permalink to &quot;HTTPS概念&quot;">​</a></h2><p>HTTP over SSL/TLS</p><h2 id="https请求过程" tabindex="-1">HTTPS请求过程 <a class="header-anchor" href="#https请求过程" aria-label="Permalink to &quot;HTTPS请求过程&quot;">​</a></h2><ol><li>C向S发起访问请求</li><li>S向C发送数字证书</li><li>C校验接收到的数字证书是否可信</li><li>如果不可信，显示警告</li><li>如果可信，提取公钥</li><li>C生成对称加密私钥对</li><li>C使用证书提取的公钥加密私钥对，发送给S</li><li>S使用证书私钥解密接收到的C端私钥对</li><li>后续通信使用C端私钥对进行</li></ol><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTM1MjExMg==&amp;mid=2247484214&amp;idx=1&amp;sn=8c5552291c1defe4ccb1d0e477751946&amp;chksm=eb075c69dc70d57f469bec570c738f94b4464a43765ff58771f42dcbd957605323af97bc328a&amp;mpshare=1&amp;scene=1&amp;srcid=0417OlFW9RyLD3hIfsdMBAaY%23rd" target="_blank" rel="noreferrer">Android新一代多渠道打包神器</a><a href="https://mp.weixin.qq.com/s/JkClcxB2JuEGOzSn1aQMZg" target="_blank" rel="noreferrer">最深刻最通俗的HTTPS 原理详解，图文并茂</a></p>',20),i=[a];function t(r,h,n,s,T,p){return c(),o("div",null,i)}const _=e(l,[["render",t]]);export{P as __pageData,_ as default};
